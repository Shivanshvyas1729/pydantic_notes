1ï¸âƒ£ 1_pydantic_why.py

ğŸ‘‰ Goal: Show how Field, Annotated, and built-in validators work

from pydantic import BaseModel, EmailStr, AnyUrl, Field
from typing import List, Dict, Optional, Annotated

ğŸ”¹ Why these imports?

BaseModel â†’ parent class for all Pydantic models

EmailStr â†’ validates email format (needs email-validator)

AnyUrl â†’ validates any URL (http, https, ftp, etc.)

Field â†’ add constraints + metadata

Annotated â†’ modern (v2) way to attach Field to a type

class Patient(BaseModel):


ğŸ‘‰ This class defines the schema + validation rules

    name: Annotated[
        str,
        Field(
            max_length=50,                     # max allowed characters
            title='Name of the patient',       # used in OpenAPI docs
            description='Give the name of the patient in less than 50 chars',
            examples=['Nitish', 'Amit']        # Swagger UI example values
        )
    ]


ğŸ“Œ Other useful Field options

min_length

regex

alias

deprecated=True

    email: EmailStr           # validates email format
    linkedin_url: AnyUrl      # validates URL

    age: int = Field(gt=0, lt=120)


ğŸ“Œ Numeric constraints

gt â†’ greater than

ge â†’ greater or equal

lt â†’ less than

le â†’ less or equal

multiple_of

    weight: Annotated[float, Field(gt=0, strict=True)]


ğŸ“Œ strict=True

âŒ "75.2" â†’ rejected

âœ… 75.2 â†’ accepted
(useful when you donâ€™t want type coercion)

    married: Annotated[
        bool,
        Field(default=None, description='Is the patient married or not')
    ]


ğŸ“Œ Optional with metadata

    allergies: Annotated[
        Optional[List[str]],
        Field(default=None, max_length=5)
    ]


ğŸ“Œ max_length=5 â†’ max number of items in list

    contact_details: Dict[str, str]


ğŸ“Œ Any string â†’ string mapping (phone, email, emergency, etc.)

patient_info = {
    'name':'nitish',
    'email':'abc@gmail.com',
    'linkedin_url':'http://linkedin.com/1322',
    'age': '30',           # STRING â†’ auto converted to int
    'weight': 75.2,
    'contact_details':{'phone':'2353462'}
}


ğŸ“Œ Pydantic does type coercion by default

2ï¸âƒ£ _field_validator.py

ğŸ‘‰ Goal: Custom validation for individual fields

from pydantic import BaseModel, EmailStr, field_validator

class Patient(BaseModel):

    @field_validator('email')
    @classmethod
    def email_validator(cls, value):


ğŸ“Œ Runs only for email field

        valid_domains = ['hdfc.com', 'icici.com']
        domain_name = value.split('@')[-1]

        if domain_name not in valid_domains:
            raise ValueError('Not a valid domain')


âœ” Enforces business rule, not format rule

    @field_validator('name')
    @classmethod
    def transform_name(cls, value):
        return value.upper()


ğŸ“Œ Used for data transformation

    @field_validator('age', mode='after')


ğŸ“Œ mode='after'

Runs after type coercion

'30' â†’ 30 â†’ then validated

Other mode:

mode='before' â†’ raw input

3ï¸âƒ£ model_validator.py

ğŸ‘‰ Goal: Validate using multiple fields together

from pydantic import BaseModel, EmailStr, model_validator

    @model_validator(mode='after')
    def validate_emergency_contact(cls, model):


ğŸ“Œ Used when:

Validation depends on more than one field

        if model.age > 60 and 'emergency' not in model.contact_details:
            raise ValueError(
                'Patients older than 60 must have an emergency contact'
            )


ğŸ“Œ Field validators âŒ
ğŸ“Œ Model validator âœ…

4ï¸âƒ£ computed_fields.py

ğŸ‘‰ Goal: Derived values (not stored, auto calculated)

from pydantic import BaseModel, EmailStr, computed_field

    @computed_field
    @property
    def bmi(self) -> float:


ğŸ“Œ Why computed field?

Not part of input

Automatically included in output

Recalculated every time

        bmi = round(self.weight / (self.height ** 2), 2)
        return bmi


ğŸ“Œ Appears in:

model_dump()

API responses

5ï¸âƒ£ nested_models.py

ğŸ‘‰ Goal: Structured & reusable models

class Address(BaseModel):
    city: str
    state: str
    pin: str

class Patient(BaseModel):
    name: str
    gender: str
    age: int
    address: Address


ğŸ“Œ Benefits:

Clean structure

Automatic validation

Reusable Address model

patient1 = Patient(**patient_dict)


ğŸ“Œ Pydantic auto-validates nested models
(no extra code needed)

6ï¸âƒ£ Serialization (model_dump)
temp = patient1.model_dump(exclude_unset=True)


ğŸ“Œ Common options:

exclude_unset=True â†’ skip default values

exclude_none=True

include={'name', 'age'}

exclude={'address'}

ğŸ”‘ Big picture (remember this)
Feature	When to use
Field	Simple constraints & metadata
Annotated	Clean modern syntax (v2)
field_validator	Single field logic
model_validator	Cross-field logic
computed_field	Derived values
Nested models	Complex structured data
